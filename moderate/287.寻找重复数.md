# 287.寻找重复数

## 题解

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = nums[0]

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        
        slow = nums[0]
        while fast != slow:
            fast = nums[fast]
            slow = nums[slow]

        return slow
```

## 解析

这道题有多种解法，这里采用快慢指针法，也叫龟兔赛跑算法，用快慢指针来寻找是否有环，如果存在环，则说明存在重复的元素，而环的入口就是重复的元素

解法分为两步，首先移动指针，慢指针每次移动一步，即slow = nums[slow]，快指针每次移动两步，即fast = nums[fast]，当它们相遇的时候就确定存在一个环，此时将其中一个指针重置到起点，两指针每次移动一步，当它们再次相遇的时候，就是指向重复元素

快慢指针tips：因为快指针和慢指针的路线其实是完全相同的，只不过快指针比慢指针跑得快一点，所以当不存在重复元素时，指针就会沿着数组不断向前，而存在重复元素时，因为出现了多个映射，导致环的形成，多个元素形成了环，而快慢指针必然经过环中的某个元素，只要经过了环，就会一直在环中转圈，而等到快慢指针都进入了环，相遇就是必然的事情

在代码中，先使用快慢指针相遇，再重置一个指针来确定入口的原理：

假设数组起点到环的入口距离为`a`，入口到第一次相遇点的距离为`b`，环的长度为`L`

则慢指针第一次走了`a+b`，快指针走了`2(a+b)`

在相遇时，快指针比慢指针多走了`kL`的长度，也就是`kL`圈，得到`2(a+b)=a+b+kL`，即`a+b=kL`，整理后得`a=kL-b`，`a=(k-1)L+(L-b)`，也就是说，当慢指针从起点走了a步到达入口点时，快指针走了`k-1`圈后又走了`L-b`步，而相遇点与入口点距离`b`，行动`L-b`后刚好再次到达入口点，和慢指针相遇
